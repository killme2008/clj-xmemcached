{
  "name": "Clj-xmemcached",
  "tagline": "Memcached client for clojure.",
  "body": "# clj-xmemcached\r\n\r\nAn opensource memcached client for clojure wraps [xmemcached](http://code.google.com/p/xmemcached/). [Xmemcached](http://code.google.com/p/xmemcached/) is an opensource high performance memcached client for java.\r\n\r\n##Leiningen Usage\r\n\r\nTo use clj-xmemcached,add:\r\n\r\n```clojure\r\n\t[clj-xmemcached \"0.3.0\"]\r\n```\r\nto your project.clj.\r\n\r\n##API docs\r\n\r\n[clj-xmemcached APIs](http://fnil.net/docs/clj-xmemcached/)\r\n\r\n## Usage\r\n\r\n### Client\r\n```clj\r\n    (require '[clj-xmemcached.core :as xm])\r\n\t(def client (xm/memcached \"host:port\"))\r\n\t(def client (xm/memcached \"host1:port1 host2:port2\" :protocol :binary))\r\n```\r\nWe create a memcached client using text protocol by default,but we can create a client using binary protocol.\r\n\r\nAlso,we can create a client using consistent hash and binary protocol:\r\n```clj\r\n\t(def client (xm/memcached \"host1:port1 host2:port2\" :protocol :binary :hash :consistent))\r\n```\r\nAll valid options:\r\n\r\n\t :protocol  Protocol to talk with memcached,a keyword in :text,:binary or :kestrel,default is text.\r\n     :hash  Hash algorithm,a keyword in  :consistent, :standard or :php, default is standard hash.\r\n     :pool  Connection pool size,default is 1,it's a recommended value.\r\n     session-locator memcached connection locator,default is created based on :hash algorithm value.\r\n     :sanitize-keys  Whether to sanitize keys before operation,default is false.\r\n     :reconnect  Whether to reconnect when connections are disconnected,default is true.\r\n     :heartbeat  Whether to do heartbeating when connections are idle,default is true.\r\n     :timeout  Operation timeout in milliseconds,default is five seconds.\r\n     :transcoder Transcoder to encode/decode data. For example, clj-json-transcoder.\r\n     :name  A name to define a memcached client instance\"\r\n\r\n### Store items\r\n```clj\r\n\t(xm/with-client client\r\n\t    (xm/set \"key1\" \"dennis\")\r\n        (xm/set \"key2\" \"dennis\" 1)\r\n        (xm/add \"key3\" \"dennis\")\r\n\t\t;;touch the key3 expire timeout to 3 seconds.\r\n\t\t(xm/touch \"key3\" 2))\r\n```\r\nUse `with-client` macro to bind the client for following operations.\r\nThe value `100` in `set` is the expire timeout for the item in seconds.Storing item functions include `set`,`add`,`replace`,`touch`,`append` and `prepend`.\r\n\r\nUnless you need the added flexibility of specifying the client for each request,you can save some typing with a little macro:\r\n\r\n```clj\r\n\t(defmacro wxm\r\n\t    [& body]\r\n\t    `(xm/with-client client ~@body))\r\n```\r\n\r\nIf you have only one client in your application, you can set the global client by:\r\n```clj\r\n\t(xm/set-client! client)\r\n```\r\nThen all the following requests will use the global client by default,except you bind another client using `with-client` macro.\r\n\r\n### Get items\r\n```clj\r\n    ;;get k1 k2 k3...\r\n    (wxm\r\n\t\t(xm/get \"key1\")\r\n\t\t(xm/get \"key1\" \"key2\" \"key3\")\r\n\t\t(xm/gets \"key1\"))\r\n```\r\nUsing `get` to retrieve items from memcached.You can retrieve many items at one time by bulk getting,but it's result is a `java.util.HashMap`.\r\n`gets` returns a clojure map contains cas and value,for example:\r\n```clj\r\n\t  {:value \"hello,dennis zhuang\", :cas 396}\r\n```\r\n### Increase/Decrease numbers\r\n```clj\r\n\t;;incr/decr key delta init-value\r\n\t(wxm\r\n\t\t(xm/incr \"num\" 1)\r\n\t\t(xm/decr \"num\" 1)\r\n\t\t(xm/incr \"num\" 1 0)\r\n```\r\nAbove codes try to increase/decrease a number in memcached with key \"num\",and if the item is not exists,then set it to zero.\r\n\r\n### Delete items\r\n```clj\r\n\t(xm/delete \"num\")\r\n\t;;delete with CAS in binary protocol.\r\n\t(xm/delete \"num\" (:cas (gets \"num\")))\r\n```\r\n### Compare and set\r\n```clj\r\n\t(xm/cas \"key\" inc)\r\n```\r\nWe use `inc` function to increase the current value in memcached and try to compare and set it at most Integer.MAX_VALUE times.\r\n`cas` can be called in:\r\n```clj\r\n\t (xm/cas key cas-fn max-times)\r\n```\r\nThe cas-fn is a function to return a new value,set item's new value to:\r\n```clj\r\n\t(cas-fn current-value)\r\n```\r\n\r\n### Distribution Lock\r\n\r\nUse memcached as a lightweight distribution lock:\r\n\r\n```clj\r\n\t(def counter (atom 0))\r\n\t(future (try-lock \"lock\" 5 (do (Thread/sleep 3000)\r\n\t                               (swap! counter inc))\r\n\t\t\t\t\t\t\t    (println \"else1\")))\r\n\t(future (try-lock \"lock\" 5 (do (Thread/sleep 3000)\r\n\t                               (swap! counter inc))\r\n\t\t\t\t\t\t\t    (println \"else2\")))\r\n\t(future (try-lock \"lock\" 5 (do (Thread/sleep 3000)\r\n\t                               (swap! counter inc))\r\n\t\t\t\t\t\t\t    (println \"else3\")))\r\n\r\n\t(Thread/sleep 4000)\r\n    (is (nil? (get \"lock\")))\r\n    (is (= 1 @counter))\r\n```\r\n\r\n### through macro\r\n\r\n\r\n```clj\r\n\t(through uid (get-user-from-databse uid))\r\n```\r\n\r\nEquals to:\r\n\r\n```clj\r\n\t(if-let [rt (get uid)]\r\n\t\trt\r\n\t    (let [rt (get-user-from-database uid)]\r\n\t\t\t(when rt\r\n\t\t\t\t(add uid rt 0))\r\n\t\t\trt))\r\n```\r\n\r\n\r\n### Shutdown\r\n```clj\r\n\t(xm/shutdown)\r\n```\r\n### Flush\r\n```clj\r\n\t(xm/flush-all)\r\n```\r\n### Statistics\r\n```clj\r\n\t(xm/stats)\r\n```\r\n\r\n### Get the raw XmemcachedClient instance\r\nBecause `memcached` function returns a delayed object,so if you want to get the raw `XmemcachedClient` instance,you have to deref it:\r\n```clj\r\n\t@client\r\n\t(xm/shutdown @client)\r\n```\r\n\r\n### Transcoders\r\n\r\nWe use [SerializationTranscoder](http://xmemcached.googlecode.com/svn/trunk/apidocs/net/rubyeye/xmemcached/transcoders/SerializingTranscoder.html) by default,it will encode/decode values using java serialization.\r\nBut since `0.2.2`, we provide a new transcoder `clj-json-transcoder` to encode/decode values using [clojure.data.json](https://github.com/clojure/data.json).It is suitable to integrate with other systems written in other languages.\r\n\r\nAnd we add `nippy-transcoder` in 0.2.3, it use [nippy](https://github.com/ptaoussanis/nippy) for serialization.\r\n\r\n### Example\r\n\r\nPlease see the example code in [example/demo.clj](https://github.com/killme2008/clj-xmemcached/blob/master/example/demo.clj)\r\n\r\n## Performance:\r\nBenchmark on my machine:\r\n\r\n\tCPU 2.3 GHz Intel Core i5\r\n\tMemory 8G 1333 MHz DDR3\r\n\tJVM options: default\r\n\r\nStart memcached by:\r\n\r\n\tmemcached -m 4096 -d\r\n\r\nBenchmark result using text protocol and 1 NIO connection:\r\n\r\n\tBenchmark set: threads=50,repeats=10000,total=500000\r\n\tElapsed time: 10990.256 msecs\r\n\tBenchmark get: threads=50,repeats=10000,total=500000\r\n\tElapsed time: 7768.998 msecs\r\n\tBenchmark set & get: threads=50,repeats=10000,total=500000\r\n\tElapsed time: 18445.409 msecs\r\n\r\nThat it is:\r\n\r\n    45495 sets/secs\r\n    64350 gets/secs\r\n\t27114 tps (both set and get an item in one round)\r\n\r\n\r\n## License\r\n\r\nCopyright (C) 2011-2020 dennis zhuang[killme2008@gmail.com]\r\n\r\nDistributed under the Eclipse Public License, the same as Clojure.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}